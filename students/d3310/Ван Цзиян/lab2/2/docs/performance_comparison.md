# Сравнение производительности

## Результаты тестирования

| Парсер | Время выполнения | Успешность | Ранг производительности |
|--------|------------------|------------|------------------------|
| Асинхронный | 3.34s | 100% (10/10) | 1-й |
| Многопроцессный | 4.98s | 90% (9/10) | 2-й |
| Многопоточный | 5.48s | 100% (10/10) | 3-й |

## Анализ результатов

### Производительность

**Асинхронный парсер** показал лучшую производительность (3.34s), что объясняется:
- Отсутствием накладных расходов на переключение контекста
- Эффективным использованием одного потока
- Минимальным потреблением памяти

**Многопроцессный парсер** занял второе место (4.98s):
- Обход GIL обеспечивает истинное параллельное выполнение
- Высокие накладные расходы на создание процессов
- Большое потребление памяти

**Многопоточный парсер** показал наихудшую производительность (5.48s):
- Ограничения Python GIL
- Накладные расходы на переключение потоков
- Синхронные HTTP-запросы

### Надежность

**Многопоточный парсер** - 100% успешность
**Асинхронный парсер** - 100% успешность  
**Многопроцессный парсер** - 90% успешность (сетевая ошибка)

## Рекомендации по выбору

### Для максимальной производительности
Выберите **асинхронный парсер** - 3.34 секунды, минимальное потребление ресурсов.

### Для максимальной надежности
Выберите **многопоточный парсер** - 100% успешность, простота отладки.

### Для CPU-интенсивных задач
Выберите **многопроцессный парсер** - обход GIL, истинное параллельное выполнение.
